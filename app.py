# app.py
import os
import subprocess
import json
import threading
import time
from flask import Flask, render_template, request, redirect, url_for, jsonify

app = Flask(__name__)
app.secret_key = "supersecretkey"

# Configurazione
SERVERS_DIR = "servers"
os.makedirs(SERVERS_DIR, exist_ok=True)

EULA_TEXT = """#By changing the setting below to TRUE you are indicating your agreement to our EULA (https://aka.ms/MinecraftEULA).
#Generated by Flask Manager
eula=true
"""

PROPERTIES_TEMPLATE = """#Minecraft server properties
accepts-transfers=false
allow-flight=false
allow-nether=true
broadcast-console-to-ops=true
broadcast-rcon-to-ops=true
bug-report-link=
difficulty=easy
enable-command-block=false
enable-jmx-monitoring=false
enable-query=false
enable-rcon=false
enable-status=true
enforce-secure-profile=true
enforce-whitelist=false
entity-broadcast-range-percentage=100
force-gamemode=false
function-permission-level=2
gamemode=survival
generate-structures=true
generator-settings={{}}
hardcore=false
hide-online-players=false
initial-disabled-packs=
initial-enabled-packs=vanilla
level-name=world
level-seed=
level-type=minecraft\\:normal
log-ips=true
max-chained-neighbor-updates=1000000
max-players=20
max-tick-time=60000
max-world-size=29999984
motd={motd}
network-compression-threshold=256
online-mode={online_mode}
op-permission-level=4
pause-when-empty-seconds=60
player-idle-timeout=0
prevent-proxy-connections=false
pvp=true
query.port={port}
rate-limit=0
rcon.password=
rcon.port=25575
region-file-compression=deflate
require-resource-pack=false
resource-pack=
resource-pack-id=
resource-pack-prompt=
resource-pack-sha1=
server-ip=
server-port={port}
simulation-distance=10
spawn-monsters=true
spawn-protection=16
sync-chunk-writes=true
text-filtering-config=
text-filtering-version=0
use-native-transport=true
view-distance=10
white-list=false
"""

# Gestione server in esecuzione
running_servers = {}  # {server_name: {"process": proc, "output": [...], "thread": ...}}


# ——————————————————— Helper ———————————————————
def get_servers():
    return [f for f in os.listdir(SERVERS_DIR) if os.path.isdir(os.path.join(SERVERS_DIR, f))]

def load_metadata(name):
    path = os.path.join(SERVERS_DIR, name, "metadata.json")
    if os.path.exists(path):
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    return None


# ——————————————————— Routes ———————————————————
@app.route("/")
def index():
    return redirect(url_for("show_my_servers"))

@app.route("/create", methods=["GET", "POST"])
def create_server():
    if request.method == "POST":
        name = request.form["name"].strip()
        ram = request.form["ram"]
        port = request.form["port"]
        cracked = "cracked" in request.form
        jar_file = request.files.get("jar_file")

        if not name or not port.isdigit() or int(port) < 1024 or int(port) > 65535:
            return "Dati non validi", 400
        if not jar_file or not jar_file.filename.endswith(".jar"):
            return "File JAR richiesto", 400

        server_dir = os.path.join(SERVERS_DIR, name)
        if os.path.exists(server_dir):
            return "Nome server già esistente", 400

        os.makedirs(server_dir)

        # Salva JAR
        jar_file.save(os.path.join(server_dir, "server.jar"))

        # Crea eula.txt
        with open(os.path.join(server_dir, "eula.txt"), "w", encoding="utf-8") as f:
            f.write(EULA_TEXT)

        # Crea server.properties
        online_mode = "false" if cracked else "true"
        props = PROPERTIES_TEMPLATE.format(motd="A Minecraft Server", online_mode=online_mode, port=port)
        with open(os.path.join(server_dir, "server.properties"), "w", encoding="utf-8") as f:
            f.write(props)

        # Salva metadata
        metadata = {
            "name": name,
            "ram": ram,
            "port": port,
            "cracked": cracked,
            "motd": "A Minecraft Server"
        }
        with open(os.path.join(server_dir, "metadata.json"), "w", encoding="utf-8") as f:
            json.dump(metadata, f, indent=2)

        return redirect(url_for("show_my_servers"))

    return render_template("create.html")

@app.route("/servers")
def show_my_servers():
    servers = get_servers()
    return render_template("servers.html", servers=servers)

@app.route("/server/<name>")
def view_server(name):
    metadata = load_metadata(name)
    if not metadata:
        return "Server non trovato", 404
    is_running = name in running_servers
    return render_template("server_detail.html", server=name, metadata=metadata, is_running=is_running)

@app.route("/server/<name>/start", methods=["POST"])
def start_server(name):
    if name in running_servers:
        return jsonify({"error": "Server già in esecuzione"}), 400

    server_dir = os.path.join(SERVERS_DIR, name)
    metadata = load_metadata(name)
    if not metadata:
        return jsonify({"error": "Metadata non trovato"}), 404

    jar_path = os.path.join(server_dir, "server.jar")
    if not os.path.exists(jar_path):
        return jsonify({"error": "server.jar non trovato"}), 404

    cmd = ["java", f"-Xmx{metadata['ram']}G", "-jar", "server.jar", "nogui"]

    try:
        proc = subprocess.Popen(
            cmd,
            cwd=server_dir,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            stdin=subprocess.PIPE,
            text=True,
            bufsize=1,
            universal_newlines=True
        )
        running_servers[name] = {
            "process": proc,
            "output": [],
            "thread": threading.Thread(target=stream_output, args=(proc, name), daemon=True)
        }
        running_servers[name]["thread"].start()
        return jsonify({"status": "avviato"})
    except FileNotFoundError:
        return jsonify({"error": "Java non trovato"}), 500

def stream_output(proc, name):
    while proc.poll() is None:
        line = proc.stdout.readline()
        if line:
            running_servers[name]["output"].append(line)
        else:
            time.sleep(0.1)
    running_servers[name]["output"].append("--- Server fermato ---\n")

@app.route("/server/<name>/stop", methods=["POST"])
def stop_server(name):
    if name not in running_servers:
        return jsonify({"error": "Nessun server in esecuzione"}), 400
    proc = running_servers[name]["process"]
    try:
        proc.stdin.write("stop\n")
        proc.stdin.flush()
        proc.wait(timeout=10)
    except:
        proc.terminate()
    finally:
        del running_servers[name]
    return jsonify({"status": "fermato"})

@app.route("/server/<name>/restart", methods=["POST"])
def restart_server(name):
    if name in running_servers:
        stop_server(name)
        time.sleep(2)
    return start_server(name)

@app.route("/server/<name>/console")
def get_console(name):
    if name not in running_servers:
        return jsonify({"lines": ["--- Server non in esecuzione ---"]})
    lines = running_servers[name]["output"][-100:]
    return jsonify({"lines": lines})

@app.route("/server/<name>/command", methods=["POST"])
def send_command(name):
    if name not in running_servers:
        return jsonify({"error": "Server non in esecuzione"}), 400
    cmd = request.json.get("command", "").strip()
    if not cmd:
        return jsonify({"error": "Comando vuoto"}), 400
    proc = running_servers[name]["process"]
    proc.stdin.write(cmd + "\n")
    proc.stdin.flush()
    return jsonify({"status": "comando inviato"})

@app.route("/edit/<name>", methods=["GET", "POST"])
def edit_server(name):
    metadata = load_metadata(name)
    if not metadata:
        return "Server non trovato", 404

    if request.method == "POST":
        new_name = request.form["name"].strip()
        ram = request.form["ram"]
        port = request.form["port"]
        cracked = "cracked" in request.form
        motd = request.form["motd"]

        if not port.isdigit() or not (1024 <= int(port) <= 65535):
            return "Porta non valida", 400

        old_dir = os.path.join(SERVERS_DIR, name)
        new_dir = os.path.join(SERVERS_DIR, new_name)
        if new_name != name and os.path.exists(new_dir):
            return "Nome già in uso", 400

        if new_name != name:
            os.rename(old_dir, new_dir)

        props_path = os.path.join(new_dir, "server.properties")
        with open(props_path, "r", encoding="utf-8") as f:
            lines = f.readlines()
        with open(props_path, "w", encoding="utf-8") as f:
            for line in lines:
                if line.startswith("server-port="):
                    f.write(f"server-port={port}\n")
                elif line.startswith("motd="):
                    f.write(f"motd={motd}\n")
                elif line.startswith("online-mode="):
                    f.write(f"online-mode={'false' if cracked else 'true'}\n")
                else:
                    f.write(line)

        metadata = {
            "name": new_name,
            "ram": ram,
            "port": port,
            "cracked": cracked,
            "motd": motd
        }
        with open(os.path.join(new_dir, "metadata.json"), "w", encoding="utf-8") as f:
            json.dump(metadata, f, indent=2)

        return redirect(url_for("show_my_servers"))

    return render_template("edit.html", server=name, metadata=metadata)


if __name__ == "__main__":
    app.run(debug=True, threaded=True)
